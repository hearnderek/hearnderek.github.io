<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <title>Hearnderek.GitHub.io by hearnderek</title>
  <link rel="stylesheet" href="stylesheets/styles.css">
  <link rel="stylesheet" href="stylesheets/github-dark.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
  <script src="javascripts/respond.js"></script>
  <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  <!--[if lt IE 8]>
    <link rel="stylesheet" href="stylesheets/ie.css">
    <![endif]-->
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

</head>

<body>
  <div id="header">
    <nav>
      <li class="fork"><a href="https://github.com/hearnderek">View On GitHub</a></li>
    </nav>
  </div><!-- end header -->

  <div class="wrapper">

    <section>
      <div id="title">
        <h1>Hearnderek.GitHub.io</h1>
        <p></p>
        <hr>
        <span class="credits left">Project maintained by <a href="https://github.com/hearnderek">hearnderek</a></span>
        <span class="credits right">Hosted on GitHub Pages &mdash; Theme by <a
            href="https://twitter.com/michigangraham">mattgraham</a></span>
      </div>

      <h2> 2022/04/19 - Revival </h2>

      <p>
        It has been a long time since I've looked at these github pages. But no time like the present to get back to using them.
      </p>

      <h2>
        The Unix Philosophy
      </h2>

      <p>
        (i) Make each program do one thing well. To do a new job, build afresh rather than complicate old programs by adding new features.
      </p> 

      <p>
        (ii) Expect the output of every program to become the input to another, as yet unknown, program. Don't clutter output with extraneous information. Avoid strignently columnar or binary input formats. Don't insist on interactive input.
      </p>

      <p>
        (iii) Design and build software, even operating systems, to be tried early, ideally within weeks. Don't hesitate to throw away the clumsy parts and rebuilt them.
      </p>

      <p>
        (iv) use tools in preference to unskilled help to lighten a programming task, even if you have to detour to build the tools and expect to throw some of them out after you've finished using them.
      </p>

      <h3>
        My thoughts
      </h3>

      <p>
        <span style="color: chocolate;"> (i) Make each program do one thing well. </span>
        This is likely the most quoted line when refering to the Unix Philosophy. 
        Akin to the programming practice of writing small and funtionally pure functions, when a tool does one thing you can hold that idea in your head very easily.
        You are more likely to reuse something you can fit into your head.
        If you have a hard time explaining what something does, users are unlikely to understand it well enough to want to try to learn the basics.
      </p>

      <p>
        <span style="color: chocolate;"> (ii) Expect the output of every program to become the input to another... </span>
        In short, make it so your program can be one part of a larger automated system.
        A gui is great for humans, but terrible for programs.
        A used tool will be part of a larger process, so have a heart and give your users the ability to automate.
      </p>

      <p>
        <span style="color: chocolate;"> (iii) Design and build software to be tried early. </span>
        This echos the ideas from Extreme Programming and Agile.
        The environment software live within is everchanging and you will inevitably make errors at every level.
        Sunlight is the best disinfectant, and more eyes will improve your project greatly.
        (That being said, sincirely listen to and consider everyone's feedback, but make your own decision.)

      </p>

      <p>
        <span style="color: chocolate;"> (iv) Build tools in preverence to enlisting unskilled help. </span>
        Tools can be a costly investment, but the same is true of people.
        The ideas brought forth by the Mythical Man Month also expands to say the even enlisting skilled help can be detremental to your project.
        If you can build a tool, you can automate. 
        But notice the use of "preference". 
        A well placed mechanical turk, as shown by the AI community around 2020, can be highly effective means for solving a technical problem.
        Those who's only solution is to build their own tool will be less effective than the manager who never makes a direct contribution.
        But a 
      </p>


      <h2>
        What I wrote when I first make this website
      </h2>
      <p>Explosions, AI take over, and all done from a distance.</p>

      <p>Started as a C++ programmer focused on making PC and Console games.</p>

      <p>Moved onto C# within XNA and Unity to build games.</p>

      <p>Began to focus on Game AI, Networking, Distributed Systems, and optimization.</p>

      <p>Worked in the game industry for 6 months (till the project I joined ended) in Unreal </p>

      <p>Pivoted over to the Mobile startup space with MeetBall as the Back-end dev. I've spent most of my time using
        .NET's WCF to write the service layer. As I could write services faster than they were requested I began
        focusing my time on other spaces. Optimization and refactors of the service code, new languages as possible
        candidates for future rewrites (if it comes to that). I've found Google's Go to be a wonderful language for just
        this, and I'm also keeping my eye on Rust for when it matures a bit more. </p>

      <p>Never sitting still because my leg won't stop bouncing - Derek</p>
    </section>

  </div>
  <!--[if !IE]><script>fixScale(document);</script><![endif]-->

</body>

</html>